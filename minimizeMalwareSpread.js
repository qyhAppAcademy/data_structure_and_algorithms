class DefaultDict {
    constructor(defaultInit) {
        return new Proxy(
            {},
            {
                get: (target, name) =>
                    name in target
                        ? target[name]
                        : (target[name] =
                            typeof defaultInit === "function"
                                ? new defaultInit().valueOf()
                                : defaultInit),
            }
        );
    }
}

var minMalwareSpread = function (graph, initial) {
    // Stores the length of the graph
    let length = graph.length;
    // Calls UnionFind constructor
    let unionFind = new UnionFind(length);

    // Find all the connected components of the graph
    for (let x = 0; x < length; x++) {
        for (let y = 0; y < length; y++) {
            if (graph[x][y]) {
                unionFind.union(x, y);
            }
        }
    }

    let infected = new DefaultDict(Number);

    // Count the number of initial infected nodes each connected component has
    for (let i = 0; i < initial.length; i++) {
        let x = initial[i];
        infected[unionFind.find(x)] += 1;
    }

    let maximumSize = 0;
    let candidateNode = Math.min(...initial);

    // Count all the infected nodes each connected component has
    for (let j = 0; j < initial.length; j++) {
        let i = initial[j];
        let infectionCount = infected[unionFind.find(i)];
        let componentSize = unionFind.sizes[unionFind.find(i)];

        if (infectionCount != 1) {
            continue;
        }
        // Return the candidate node from largest length connected component
        if (componentSize > maximumSize) {
            maximumSize = componentSize;
            candidateNode = i;
        } else if (componentSize == maximumSize && i < candidateNode) {
            candidateNode = i;
        }
    }

    return candidateNode;
};

class UnionFind {
    constructor(n) {
        this.parents = Array.from({ length: n }, (_, i) => i)
        this.sizes = Array(n).fill(1);
    }
    
    // Function to find which subset a particular element belongs.
    find(i) {
        while (i != this.parents[i]) {
            this.parents[i] = this.find(this.parents[i]);
            i = this.parents[i];
        }
        return i
    }

    // Function to join two subsets into a single subset.
    union(x, y) {
        let rootX = this.find(x);
        let rootY = this.find(y);

        if (rootX == rootY) {
            return;
        }

        let r = this.sorted(rootX, rootY, this.sizes);
        let small = r[0];
        let big = r[1];
        this.parents[small] = big;
        this.sizes[big] += this.sizes[small];
    }

    sorted(x, y, sizes) {
        let mapping = {};
        mapping[sizes[x]] = x;
        mapping[sizes[y]] = y;
        let tempSizes = [sizes[x], sizes[y]]

        if (sizes[x] == sizes[y]) {
            return [x, y];
        } else {
            tempSizes.sort(function (a, b) { return a - b });
            return [mapping[tempSizes[0]], mapping[tempSizes[1]]];
        }
    }
}